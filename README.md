# My Advent of Code Solutions!
## 2024:
### Day 1:
**Part 1:**
You can sort the arrays (A: contains the numbers on the left, B: contains the numbers on the right) and find the difference between each position in A and B.

**Part 2:**
You can use a map to find out how many, of the number you are searching for, is in B. So, do that for each number in A. (Sorry for a confusing explanation!)
### Day 2-17:
Coming Soon!
### Day 18:
**Part 1:**
You can do a simple BFS with a seen array/map to see if you have gone to that location before.

**Part 2:**
You can do a BFS for each new location. My code does take around 10 seconds or more to finish, but it doesn't take too long.
### Day 19:
**Part 1:**
Simple Brute Force. You can use a queue and a seen array for each position of each string/design and see if there is a way to create that design.

**Part 2:**
Pretty simple DP. Instead of using a queue, just use a vector and go through all the positions from left to right of each design and, in the end, see how many different ways there are to create the design.
### Day 20-21:
Coming Soon!
### Day 22:
**Part 1:**
Simple Brute Force. You can just get the 2000th secret number for each secret number.

**Part 2:**
Simple Brute Force. You find every sequence of four changes in the secret moves and see which one gets you the most bananas. However, it does take a little bit (10-20 seconds).
### Day 23:
**Part 1:**
Simple Brute Force. You can try every three possible computers and see if they are connected and if one of them starts with a t.

**Part 2:**
I have no idea how to solve this problem, so I can't explain the solution (of course). I used Jonathan Paulson's code instead, so check that one out!
## 2023:
Coming Soon!

## 2022:
Coming Soon!

## 2021:
Coming Soon!

## 2020:
Coming Soon!

## 2019:
Coming Soon!

## 2018:
Coming Soon!

## 2017:
Coming Soon!

## 2016:
Coming Soon!

## 2015:
Coming Soon!
